# CPU 스케줄링

- 운영체제의 CPU 스케줄러는 Ready 상태의 프로세스 중에서 어떤 프로세스에게 CPU를 할당할지 결정

## CPU 스케줄링 목적

- CPU 활용도 높이기

    비싼 자원이기 때문에 계속 활용해야한다.

- 시스템 성능 향상

- 공정성 보장

- 데드락 방지

## 규모에 의한 스케줄링 구분

- 장기 스케줄러

    어떤 프로세스를 준비 큐에 넣을 것인지 결정

- 중기 스케줄러

    메모리에 적재된 프로세스의 수를 관리 

- 단기 스케줄러

    어떤 프로세스(= 준비상태의)에게 CPU를 할당해 줄 것인가를 결정

## 프로세스의 우선순위

- 프로세스의 우선순위는 프로세스가 CPU를 할당받을 순서를 결정하는 데 사용된다.

- 우선순위가 높은 프로세스는 우선순위가 낮은 프로세스보다 먼저 CPU를 할당받는다.

- 프로세스의 우선순위는 다양한 요소에 따라 결정될 수 있으며, 이에는 프로세스의 유형, 요구되는 리소스 양, 실행 시간 등이 포함된다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbesxn7%2Fbtrtys87XY9%2FIGxZ42PUNNKPCaiZrlA0O0%2Fimg.png" width="800" height="500">

- 커널과 관련된 작업들은 보통 일반 프로세스보다 중요하기 때문에 커널 프로세스 우선순위 높음

- IO bound process의 경우 CPU를 할당받아도 금방 대기 상태로 빠지는 반면 CPU bound process의 경우 할당받은 CPU 시간을 전부 사용하는 경우가 많기 때문에 IO bound Process 우선순위가 높음

- 전면 프로세스는 사용자의 요구를 즉각 반응해야 하지만 후면 프로세스는 상호작용이 없기 때문
    - 전면 프로세스

        GUI를 사용하는 OS에서 화면 맨 앞에 놓인 프로세스
    - 후면 프로세스

        후면 프로세스는 사용자와 상호작용이 없는 프로세스

- 대화형 프로세스는 사용자의 입력을 받아 즉시 반응하고 결과를 반환하는 것이 중요하다. 
반면에, 일괄처리 프로세스는 대량의 데이터를 처리하는 데 중점을 두며, 사용자의 개입 없이 자동으로 실행되기 때문에 대화형 프로세스가 더 중요


## 스케줄링 큐 관리

- CPU를 사용할 다음 프로세스를 찾기 위해 모든 프로세스의 PCB를 확인하는 것은 비효율적

- 스케줄링 큐는 CPU가 처리할 프로세스의 목록을 관리한다.

- 프로세스가 시스템에 도착하면 준비 큐에 추가되고, CPU가 사용 가능해지면 이 큐에서 프로세스가 선택되어 실행된다.

<img src="https://velog.velcdn.com/images/shjung53/post/d46fb6ec-3e9c-4e75-a96a-3a105f7b025f/image.png
" width="800" height="500">

- 준비 큐

    CPU를 이용하고 싶은 프로세스들이 서는 줄

- 대기 큐

    입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄

## 선점형, 비선점형 스케줄링

### 선점 스케줄링 (Preemptive Scheduling)

- 운영체제의 판단에 따라 현재 실행 중인 프로세스를 강제로 중단시키고, CPU 스케줄링을 수행한다.

- 타이머 인터럽트가 발생하거나 입출력 완료 시에 해당 된다.

- 각 프로세스의 빠른 응답을 지원할 수 있다.

- Context Switch을 위한 커널 코드가 실행이 빈번하게 발생하여 overhead가 증가한다. 

 
### 비선점 스케줄링 (Nonpreemptive Scheduling)

- 현재 실행 중인 프로세스가 자발적으로 CPU 사용을 중단하는 경우에만 CPU 스케줄링을 수행하는 방법

- 실행중인 프로세스가 종료되거나 (Running -> Terminated)

- 외부 장치 입출력 요청 시 (Running -> Waiting) 프로세스가 스스로 CPU 사용을 중단하고, 자신의 상태를 변경한다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcfQK5z%2FbtqJCt69UHK%2F0wvymmPLWkObHGgMVAq6B1%2Fimg.png" width="800" height="500">

<br>

## 스케줄링 알고리즘

### 선입 선처리 스케줄링 / FCFS(first-come, first-served)

- 비선점형으로 준비 큐에 삽입된 순서대로 처리

- 먼저 CPU 요청한 프로세스부터 할당

- 프로세스들이 기다리는 시간이 매우 길어질 수 있다 ( = 호위 효과)

### 최단 작업 우선 스케줄링 / SJF(shortest-job-first)

- 호위 효과를 방지하기 위해 CPU 사용이 긴 프로세스는 나중에 실행

###  라운드 로빈 스케줄링 / RR(round-robin)

- 선입 선처리 스케줄링 + 타임 슬라이스

    - 타임 슬라이스

        각 프로세스가 CPU를 사용할 수 있는 정해진 시간

- 큐의 프로세스들은 타임 슬라이스 시간 동안 CPU를 이용 ( 선점형 스케줄링 )

- 타임 슬라이스동안 완료되지 않으면 큐의 맨 뒤에 삽입

- 타임 슬라이스의 크기가 중요하다

- 너무 커지면 선입 선처리 스케줄링과 비슷해짐

- 너무 작으면 Context Switching으로 인해 Overhead가 너무 커짐

###  최소 잔여 시간 우선 스케줄링 / SRTF(shortest-remaining-time-first)

- 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링

- 타임슬라이스 만큼 CPU를 이용하면서 다음 프로세스는 작업시간이 가장 적은 프로세스로 할당

### 우선순위 스케줄링 / Priority

- 프로세스에 우선순위를 부여하고, 우선순위가 높은 프로세스부터 실행

- 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링

        - 기아 현상

        우선 순위가 높은 프로세스만 계속 실행되어 우선 순위가 낮은 프로세스는 계속 후순위로 밀려 실행되지 못하는 현상

        - 에이징

        기아 현상을 방지하기 위해 오랫동안 대기한 프로세스의 우선 순위를 점차 높여서 실행될 수 있도록 하는 기법

### 다단계 큐 스케줄링 / Multilevel queue

- 우선순위별로 준비 큐를 여러 개 사용

- 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리

- 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스 처리

- 큐 간의 이동이 불가능하기 때문에 기아 현상이 다시 발생할 수 있다.

### 다단계 피드백 큐 스케줄링

- 큐 간의 이동이 가능한 다단계 큐 스케줄링

- 새롭게 준비 상태가 된 프로세스를 가장 높은 우선순위 큐에 삽입.

- 타임슬라이스만큼 프로세스를 실행하고 해당 큐에서 실행이 완료되지 않으면 다음 우선순위 큐에 삽입.

- CPU를 비교적 오래 사용하는 CPU 집중 프로세스들은 점점 우선 순위가 낮은 큐에 삽입된다.

- 이렇게 낮은 우선 순위로 밀려나는 프로세스들은 다시 에이징 기법을 적용하여 높은 우선순위 큐로 이동하게 하여 기아 현상을 방지.

## 참고
https://velog.io/@shjung53/os-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%ED%81%90

혼자공부하는 컴퓨터구조 운영체제