# 프로세스란

- 컴퓨터에서 실행중인 프로그램

    - 프로그램

        컴퓨터가 실행할 수 있는 명령어들의 집합

- 각각의 프로세스는 독립된 메모리 공간을 할당 받음

- 명령어들과 데이터를 가진다

<br>

# PCB(Process Control Blcok)

- 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳

- 프로세스의 상태 정보를 저장하는 구조체

- 프로세스 상태 관리와 Context Switching을 위해 필요하다.

- PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지된다.

### PCB 구성 요소

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb4UqL0%2FbtrYUTOnW6g%2FBmY67Z1UPkLiMyO4ax3lYk%2Fimg.jpg" width="300" height="400">

#### 프로세스 ID(Process ID)

프로세스 ID, 해당 프로세스의 자식 프로세스 ID

#### 프로세스 상태(Process State)

프로세스의 현재 상태를 나타낸다. 예를 들면, 실행(Running), 준비(Ready), 대기(Waiting) 등의 상태 등이 있다. 이 상태 정보는 프로세스 스케줄링과 상호작용하여 프로세스의 실행을 관리한다.

#### 프로세스 우선순위(Process Priority) 

프로세스의 실행 순서를 결정하는 우선순위

#### 프로세스 권한

컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보

#### 프로그램 카운터(Program Counter, PC)

프로세스가 다음에 실행할 명령어(코드)의 주소를 가리키는 포인터이다. PC는 프로세스가 중단되었을 때 다시 시작할 위치를 알려주는 중요한 역할을 한다.

#### CPU 레지스터(Registers)

프로세스가 현재 실행되는 동안 사용되는 레지스터 값들을 저장한다. 여기서 프로세스가 일시 중단되고 다시 실행 될 때 레지스터 값들을 복원하는 데 사용된다.

#### CPU 스케줄링 정보(Scheduling Information)

프로세스의 우선순위, 할당 된 CPU 시간, 스케줄링 알고리즘과 관련된 정보 등 스케줄링에 필요한 정보를 포함한다.

#### 계정 정보(Accounting Information) 

프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보

#### 메모리 관리 정보(Memory Management Information)

프로세스가 사용하는 메모리 공간의 주소 범위, 페이지 테이블, 메모리 할당 정보 등과 같이 메모리 관리에 필요한 정보를 저장한다.

#### 입출력 상태(I/O state)

프로세스가 현재 사용 중인 입출력 장치와 관련된 정보를 포함한다. 예를 들어, 어떤 입출력 요청을 보내고 있는지, 어떤 파일을 열어두었는지 등의 정보를 저장한다.

<br>

# Context Switching

- CPU/코어에서 실행 중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것

### Context란

- 프로세스/스레드 (CPU / 메모리)의 상태

### 목적

- 여러 프로세스/스레드를 동시에 실행시키기 위해서

### Context Switching이 언제 발생하는지

- 주어진 time slice 즉, 퀀텀을 다 사용한 경우

- I/O 작업을 해야하는 경우

- 다른 리소스를 기다려야 하는 경우

### 과정

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcLs4ee%2Fbtq6zCgeEaS%2FeMkhgp9failtca7VYSgbkk%2Fimg.png" width="800" height="500">

- idle : 유휴상태

1. P0 실행

2. 요청 발생: 인터럽트 요청이 발생.

3. PCB에 저장: 운영체제는 현재 실행중인 프로세스(P0)의 정보를 PCB에 저장.

4. CPU 할당: 운영체제는 다음 프로세스(P1)의 정보를 PCB에서 가져와 CPU를 할당.

- 위 과정을 반복적으로 수행. Context Switching하는 동안 오버헤드가 잦아지면 성능이 떨어질수 있다.

<br>

# 프로세스 메모리 구조

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcqk9Wt%2Fbtq9Rehkwfd%2F6QNk4WEKb7O7JR4TvXakvK%2Fimg.png" width="800" height="500">

#### 코드(Text) 영역

- 사용자가 작성한 프로그램 코드가 기계어 명령으로 변환되어 저장되는 공간

- 이 영역은 변경이 불가능한 Read-Only 상태이다.

#### 데이터 영역

- 전역 변수나 static 변수 등의 데이터가 저장되는 공간

- 초기화된 전역 변수는 GVAR 영역에, 초기화되지 않은 전역 변수는 BSS 영역에 저장된다. 

- 이 영역은 컴파일 시에 생성되며, 프로그램 종료 시 삭제된다. 

- 그리고 이 영역은 변수의 값 변경이 가능한 Read-Write 상태이다.

#### 힙 영역

- 프로그래머가 필요에 따라 동적으로 메모리를 할당하고 해제하는 공간

- 주소값은 커지는 방향으로 영역이 확장된다.

#### 스택 영역

- 함수 호출 시 임시로 데이터를 저장하는 공간

- 호출된 함수의 반환 주소, 지역 변수, 매개변수, 리턴값 등이 저장된다.

- 함수 수행 완료 시 데이터는 삭제된다. 데이터는 LIFO (Last In First Out) 방식으로 적재되며, 주소값은 작아지는 방향으로 영역이 확장된다.

- 스택 영역과 힙 영역이 만나게 되면 메모리가 소진되었다는 의미이며, 이 상태에서 계속 데이터를 저장하게 되면 스택 오버플로우가 발생한다.

<br>

# 프로세스 상태(다이어그램)

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99F987335A5360A209" width="800" height="500">

### 생성(New) 상태

프로세스가 생성되었으나 아직 운영체제에 의해 실행 가능한 상태로 전환되지 않은 상태이다.

### 준비(Ready) 상태

프로세스가 CPU를 할당받기를 기다리는 상태이다.

### 실행(Run) 상태

프로세스가 CPU를 할당받아 실제로 실행되는 상태이다.

### 디스패치(Dispatch)

준비 상태의 프로세스가 CPU를 할당받아 실행 상태로 전환되는 과정을 말한다.

### Time Runout

실행 상태의 프로세스가 할당받은 CPU 사용 시간이 끝나 준비 상태로 되돌아가는 과정을 말한다.

### 종료(Exit) 상태

프로세스의 실행이 완전히 끝나 CPU 할당이 해제된 상태를 말한다.

### 대기(Wait) 상태

프로세스가 CPU를 할당받아 실행 중에 특정 이벤트(예: 입출력 작업 완료)가 발생할 때까지 일시 중지된 상태를 말한다.

### Wake Up

대기 상태에 있던 프로세스가 기다리던 이벤트가 발생하여 준비 상태로 전환되는 과정을 말한다.

- 추가로, 프로세스의 상태 전환은 운영체제의 스케줄링에 따라 변화하며, 이용 가능한 CPU의 수, 운영체제의 스케줄링 방식, 프로세스의 우선순위 등이 프로세스의 상태 전환에 영향을 미칠 수 있다. 이러한 요소들은 프로세스의 성능과 실행 시간을 결정하는 중요한 요소이다.

<br>

# 프로세스 생성

- 생성된 자식 프로세스 또한 부모 프로세스가 되어 새로운 자식 프로세스를 생성할 수 있다.

- 프로세스는 자신의 메모리 영역을 복제하여 자식 프로세스를 생성한다. 이 과정은 fork() 시스템 콜을 통해 이루어진다. 

- 하지만 fork() 시스템 콜만으로는 부모 프로세스와 동일한 자식 프로세스만 생성할 수 있다.

- 서로 다른 프로그램을 실행하기 위해선 exec() 시스템 콜이 필요하다. exec() 시스템 콜은 fork()를 통해 생성한 메모리 공간에 새로운 데이터를 덮어쓴다.

### 과정

<img src="https://velog.velcdn.com/images%2Fyuseogi0218%2Fpost%2F1ff950ea-702e-4d86-9d9c-0fb813ad8c5d%2Fimage.png" width="800" height="500">

<br>

- 부모 프로세스가 연산을 통해 자식 프로세스를 트리구조로 생성한다.

- 각 프로세스를 각각 식별하고 관리하고 위하여 고유의 PID(Process Identifier) 를 가진다.

<br>

<img src="https://velog.velcdn.com/images%2Fyuseogi0218%2Fpost%2F3d1f151c-eac7-4744-89e6-87cc9e8853a3%2Fimage.png" width="800" height="500">

### fork() 시스템 콜

- fork()는 현재 실행 중인 프로세스의 복제본을 생성하는 시스템 콜이다.

- 자식 프로세스는 부모 프로세스의 자원을 상속받는다. 이때 자원이란 메모리 내용, 열린 파일 목록 등을 의미한다. 

- 복제된 자식 프로세스라도 pid 값과 저장된 메모리 위치는 부모 프로세스와 다르다.

- 부모 프로세스에서는 'fork'가 자식 프로세스의 PID(Process ID)를 반환하고, 자식 프로세스에서는 'fork'가 0을 반환한다.

<img src="https://velog.velcdn.com/images%2Fyuseogi0218%2Fpost%2Fcb52c2b0-85e3-45c4-8d55-fdb79c5a58fa%2Fimage.png" width="800" height="500">

### exec() 시스템 콜

- exec()는 새로운 프로그램을 메모리에 로드하고 실행하는 시스템 콜이다.

- storage 영역에 저장되어 있는 자식프로세스의 실행 가능한 코드와 데이터를 메모리로 가져옴

<img src="https://velog.velcdn.com/images%2Fyuseogi0218%2Fpost%2F3e2d3061-e14c-4683-a680-0bef6f3d1389%2Fimage.png" width="800" height="500">

###  wait() 시스템 콜

- 부모 프로세스가 자식 프로세스의 종료를 기다리는데 사용되는 시스템 콜이다.

- 프로세스 간 동기화를 위해 사용된다.

# 스레드

- 프로세스가 가지고 있는 자원들을 이용하는 하나의 실행 흐름 단위

- 하나의 프로세스는  하나 이상의 스레드를 갖고 있다.

- 운영체제의 스케줄러에 의해 독립적으로 관리될 수 있는 프로그래밍된 명령어의 가장 작은 시퀀스

- 프로세스 하나만을 사용하기엔 메모리 낭비가 발생

- 그러나 스레드는 서로 메모리를 공유하여 실행

<img src="https://velog.velcdn.com/cloudflare/aeong98/411e94f9-758b-40e3-93cb-938cde5fbd15/image.png" width="800" height="500">

### 스레드가 독립적으로 가지고 있는 부분

- program counter
- register set
- stack space

### 공유하는 부분

- code section
- data section
- OS resources

### 스택을 독립적으로 할당하는 이유

스택은 함수 호출 시 전달되는 인자, 돌아갈 주소값, 함수 내에서 선언하는 변수 등을 저장하는 메모리 공간이다. 따라서 이를 독립적으로 할당한 다는 것은 독립적인 함수 호출이 가능하다는 것이며 독립적인 실행 흐름이 추가되는 것.

따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위해 독립된 스택을 할당하는 것임.

### PC 레지스터를 독립적으로 할당하는 이유

PC 값은 스레드가 명령어의 어디까지 수행하였는지 나타낸다. 스레드는 CPU를 할당받았다가 스케줄러에 의해 다시 선점 당하기 때문에 명령어가 연속적으로 수행되지 못하여 어디까지 수행한지 저장해둘 필요가 있다.

따라서 독립적으로 할당하는 것.


# 멀티 프로세스 & 멀티 스레드
## 멀티 프로세스
- 하나의 애플리케이션을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것입니다.

- 프로세스끼리 별개의 메모리 영역을 확보하게 됩니다.

- 프로세스는 각각의 동립된 영역을 할당당았기 때문에, 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다. 때문에, 프로세스 간 통신을 하기 위해서는 IPC를 통해야 한다.

## 멀티 스레드

- 하나의 어플리케이션을 여러개의 스레드로 구성하고 각 스레드가 작업을 처리하는 것.

- 멀티 프로세스 대신 멀티 스레드를 사용하는 것은 '하나의 프로그램 안에서 여러 작업을 해결하는 것' 이라고 할 수 있다.

### 리소스 공유 장단점

#### 장점
- 효율적인 자원 사용

스레드는 프로세스 내의 코드, 데이터, 파일 등의 시스템 자원을 공유하므로 자원 사용이 효율적이다. 이로 인해 메모리 사용량이 줄고, 시스템의 전반적인 효율성이 향상된다.

- 빠른 통신

스레드는 같은 프로세스 내에서 메모리를 공유하므로 통신이 빠르고 간단하다. 별도의 IPC(Inter-Process Communication) 메커니즘 없이도 데이터를 주고받을 수 있다.

- 빠른 컨텍스트 스위칭

스레드 간의 컨텍스트 스위칭은 프로세스 간의 컨텍스트 스위칭보다 빠르고 효율적이다. 이는 스레드가 공유 메모리를 통해 정보를 주고받기 때문이다.

#### 단점

- 동기화 문제

여러 스레드가 동일한 메모리를 공유하면, 동기화 문제가 발생할 수 있다.

- 데이터 보호 문제

여러 스레드가 동일한 메모리 공간에 접근할 수 있으므로, 데이터 보호가 어려울 수 있다.

- 오류 전파

스레드에서 발생한 오류가 전체 프로세스에 영향을 미칠 수 있다. 이는 모든 스레드가 프로세스의 메모리를 공유하므로, 하나의 스레드에서의 오류가 다른 스레드에 영향을 미칠 수 있다.

    Chrome은 멀티프로세싱을 사용하여 한 탭에 오류가 발생하더라도 다른 탭에 영향 X

    Explore는 멀티스레드를 사용하여 한 탭에 오류가 발생하면 다른 탭에 영향 O

