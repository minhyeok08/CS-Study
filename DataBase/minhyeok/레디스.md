# Redis (Remote Dictionary Server)

Remote(원격)에 위치하고 프로세스로 존재하는 In-Memory 기반의 Dictionary(key-value) 구조 데이터 관리 Server 시스템

### 특징

- 레디스는 모든 데이터를 메모리에 저장하고 조회하는, 인메모리 데이터베이스다.

- 데이터의 고속 읽기와 쓰기에 최적화 되어 있다.

- Key-Value 타입의 저장소

- 읽기 성능 증대를 위한 서버 측 복제를 지원

- 쓰기 성능 증대를 위한 클라이언트 측 샤딩(Sharding) 지원

- 다른 인메모리 데이터베이스와 가장 큰 차이점은 바로 레디스의 다양한 자료구조를 지원한다는 점.

### 다양한 자료구조

- 레디스는 문자열, 리스트, 해시, 셋, 정렬된 셋 등 여러 가지 자료구조를 지원한다.

- 이런 다양한 자료구조를 지원함으로써 개발의 편의성이 향상되고 난이도가 낮아진다.

        예를 들어, 어떤 데이터를 정렬해야 하는 상황에서 DBMS를 이용시 DB에 데이터를 저장하고, 저장된 데이터를 정렬하여 다시 읽어오는 과정은 디스크에 직접 접근을 해야 하기 때문에 시간이 더 걸린다는 단점이 있다. 그러나 이 때 인메모리 데이터베이스인 레디스를 이용하고 레디스에서 제공하는 Sorted-Set이라는 자료구조를 사용하면 더 빠르고 간단하게 데이터를 정렬할 수 있다.

<br>

## Redis는 어디에 사용하는지?

### 캐시 서버의 역할

- Redis는 빠른 응답 시간을 가진 인 메모리 저장소로서, 캐시 서버로 자주 활용된다.

- 예를 들면, 웹 애플리케이션에서 DB로부터 조회한 데이터를 Redis에 임시로 저장해두면, 같은 조회 요청이 들어올 때 데이터베이스가 아닌 Redis로부터 빠르게 데이터를 가져올 수 있다.

- 이런 방식은 데이터베이스의 부하를 줄이고, 애플리케이션의 응답 시간을 향상시키는 효과가 있다.

### API 캐싱 역할

- API 캐싱 역할은 캐시 서버 역할의 한 형태라고 볼 수 있다.

- API의 응답을 Redis에 저장해두면, 같은 API 요청이 들어올 때 저장된 응답을 반환한다.

- 이렇게 함으로써 API를 처리하는 백엔드 서버의 부하를 줄이고, API의 응답 시간을 크게 단축시킬 수 있다.

- 특히, 계산이 복잡하거나 데이터베이스 조회가 필요한 API의 경우, 이런 API 캐싱은 큰 효과를 볼 수 있다.

### 메세지 브로커 역할

- 메세지 브로커는 메세지를 전달하는 중개자 역할을 한다.

- Redis는 퍼블리시/서브스크라이브(pub/sub) 모델을 지원하므로, 메세지 브로커로 활용될 수 있다.

- 예를 들어, 하나의 서비스(퍼블리셔)가 메세지를 Redis에 전달하면, 그 메세지를 구독하고 있는 다른 서비스(서브스크라이버)들이 그 메세지를 받아 처리할 수 있다.

- 이런 방식은 마이크로서비스 아키텍처에서 서비스 간의 비동기 통신을 구현하는 데 효과적이다.

### 세션 스토어

- Redis를 세션 스토어로 사용하면 여러 서버간의 세션 공유가 가능하다.

- 이는 로드 밸런싱 환경에서 특히 유용하다. 사용자의 요청이 여러 서버 중 어느 하나에게 도달하더라도, 모든 서버가 동일한 세션 스토어인 Redis를 공유하므로 일관된 세션 정보를 유지할 수 있다.

### 레디스의 영속성

- 레디스는 영속성을 보장하기 위해 데이터를 디스크에 저장할 수 있다. 서버가 내려가더라도 디스크에 저장된 데이터를 읽어 메모리에 로딩한다.

#### 데이터를 디스크에 저장하는 방식

#### RDB(Redis Database)
- 특정 시점의 레디스 데이터(스냅샷)를 나타내는 여러 개의 데이터 파일을 생성하는 방식이다.

- main 프로세스는 child 프로세스를 생성만 하고, RDB 명령 실행은 child 프로세스를 통해 수행하기 때문에 레디스의 읽기/쓰기에 거의 영향을 미치지 않는다.

- RDB 데이터 파일을 기반으로 레디스를 복구하고 재시작하는 것이 AOF 방식보다 빠르다.

- 일반적으로 RDB 데이터 스냅샷 파일은 5분 이상 주기로 생성되며, 이 때 레디스가 다운된다면 해당 주기 만큼의 데이터를 손실하게 된다.

- 레디스 데이터가 너무 큰 경우 child process를 fork하는 과정에서 서비스 중단이 발생할 수 있다.

#### AOF(Append Only File)
- 각 쓰기 명령을 로그로 간주하고 로그 파일에 저장한다. 해당 로그 파일은 append-only 모드로 쓰여진다.

- AOF는 RDB 방식보다 데이터 손실을 더 적게 가져갈 수 있다. 일반적으로 백그라운드 스레드를 통해 1초마다 fsync 명령을 수행한다.

- AOF는 특정 시점에 rewrite를 실행하여 현재 메모리 정보를 로그파일로 재기록하는데, 이를 통해 로그파일의 사이즈를 줄일 수 있다.

- AOF 로그 파일은 읽기 쉬운 방식으로 제공된다. 만약 누군가 flushall 명령으로 데이터를 날려버렸다면  AOF 파일에서 flushall만을 제거하여 복구할 수 있다.

- 동일한 데이터의 경우 AOF 로그파일은 일반적으로 RDB 파일보다 크다.

#### RDB와 AOF 동시 사용

- RDB와 AOF를 동시에 사용하는 경우 레디스가 다시 시작될 때 AOF 데이터가 더 완전하다고 판단하여 AOF를 사용해 데이터를 다시 저장한다.

### 싱글 스레드를 사용하는 레디스 (?)

## 레디스 장단점
### 장점
#### 빠른 응답 시간
레디스는 인메모리 데이터베이스로, 데이터를 메모리에 저장하고 처리한다. 이로 인해 디스크 I/O가 없으므로 데이터 액세스 시간이 상당히 빠르다.
#### 다양한 데이터 구조 지원
레디스는 단순한 키-값 저장소가 아니라 리스트, 세트, 해시, 정렬된 세트 등 다양한 데이터 구조를 지원한다. 이로 인해 다양한 유형의 애플리케이션에 적합하다.
#### 데이터 영속성
레디스는 RDB와 AOF라는 두 가지 방법을 통해 디스크에 데이터를 백업하고, 시스템 장애 시 데이터를 복구할 수 있다.
#### Pub/Sub 메시징 시스템
레디스는 발행/구독 모델을 지원하여, 실시간 채팅, 소셜 네트워크 업데이트, 실시간 분석 등을 구현하는 데 사용할 수 있다.
#### 트랜잭션 지원
레디스는 여러 명령을 하나의 트랜잭션으로 묶어 처리하는 기능을 제공한다.
#### 높은 확장성
레디스 클러스터를 통해 수천 개의 노드를 지원하고, 데이터를 여러 노드에 분산할 수 있다. 이로 인해 레디스는 매우 높은 수준의 확장성을 가진다.
### 단점
#### 메모리 기반
레디스는 기본적으로 데이터를 메모리에 저장하므로 데이터가 휘발성을 가진다. 시스템이 다운되면 데이터 손실이 발생할 수 있다. 레디스는 이를 방지하기 위해 디스크에 데이터를 백업하는 RDB와 AOF와 같은 영속성 메커니즘을 제공하지만, 이 메커니즘도 완전한 데이터 손실 방지를 보장하지는 않는다.
#### 데이터 크기 제한
레디스는 메모리 기반의 데이터베이스이므로, 사용 가능한 메모리 크기에 따라 저장 가능한 데이터의 크기가 제한된다. 때문에 레디스를 사용할 때 메모리 관리는 중요한 고려사항이다.
#### 싱글 스레드 모델
레디스는 싱글 스레드 모델을 사용하므로, 멀티 코어 CPU의 모든 코어를 활용하지 못하고, 한 번에 하나의 명령만 처리할 수 있다. 이는 레디스의 처리 능력에 한계를 가져올 수 있다.
#### 복잡한 데이터 모델링
레디스는 기본적으로 키-값 구조를 사용하므로, 복잡한 데이터 모델링이 필요한 경우 적합하지 않을 수 있다. 레디스는 다양한 데이터 구조를 제공하지만, 이들을 통합하는 복잡한 쿼리를 작성하는 것은 어렵다.



